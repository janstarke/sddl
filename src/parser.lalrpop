use std::str::FromStr;

grammar;
/*
pub Ace: crate::Ace = {
    "(" <t:AceType> ";" AceCon ")" => {
        if t == SDDL_ACCESS_ALLOWED {}
        els if 
    }
}
*/
AceType: &'static str = {
    "A" => crate::sddl_h::SDDL_ACCESS_ALLOWED,
    "D" => crate::sddl_h::SDDL_ACCESS_DENIED,
    "AU" => crate::sddl_h::SDDL_AUDIT,
    "AL" => crate::sddl_h::SDDL_ALARM,
    "OA" => crate::sddl_h::SDDL_OBJECT_ACCESS_ALLOWED,
    "OD" => crate::sddl_h::SDDL_OBJECT_ACCESS_DENIED,
    "OU" => crate::sddl_h::SDDL_OBJECT_AUDIT,
    "OL" => crate::sddl_h::SDDL_OBJECT_ALARM,
    "XA" => crate::sddl_h::SDDL_CALLBACK_ACCESS_ALLOWED,
    "XD" => crate::sddl_h::SDDL_CALLBACK_ACCESS_DENIED,
    "ZA" => crate::sddl_h::SDDL_CALLBACK_OBJECT_ACCESS_ALLOWED,
    "XU" => crate::sddl_h::SDDL_CALLBACK_AUDIT,
    "ML" => crate::sddl_h::SDDL_MANDATORY_LABEL,
    "RA" => crate::sddl_h::SDDL_RESOURCE_ATTRIBUTE,
    "SP" => crate::sddl_h::SDDL_SCOPED_POLICY_ID,
    "TL" => crate::sddl_h::SDDL_PROCESS_TRUST_LABEL,
    "FL" => crate::sddl_h::SDDL_ACCESS_FILTER,
}

pub AceFlag: crate::AceFlags = {
    <s:SingleAceFlag> => s,
    <a:AceFlag> <s:SingleAceFlag> => a | s
}

pub SingleAceFlag: crate::AceFlags = {
    "OI" => crate::AceFlags::OBJECT_INHERIT_ACE,
    "CI" => crate::AceFlags::CONTAINER_INHERIT_ACE,
    "NP" => crate::AceFlags::NO_PROPAGATE_INHERIT_ACE,
    "IO" => crate::AceFlags::INHERIT_ONLY_ACE,
    "ID" => crate::AceFlags::INHERITED_ACE,
    "CR" => crate::AceFlags::CRITICAL,
    "SA" => crate::AceFlags::SUCCESSFUL_ACCESS_ACE_FLAG,
    "FA" => crate::AceFlags::FAILED_ACCESS_ACE_FLAG,
    "TP" => crate::AceFlags::TRUST_PROTECTED_FILTER,
}

pub AccessMask: crate::AccessMask = {
    <n:Number> => crate::AccessMask::from(n),
    <s:SingleAccessMask> => s,
    <a:AccessMask> <s:SingleAccessMask> => a | s
};


Number: u32 = {
    <s:r"(0|0x)?[0-9a-fA-F]+"> => {
        if s.len() == 1 {
            u32::from_str(s).unwrap()
        } else {
            if s.chars().next().unwrap() == '0' {
                let s = &s[1..];
                if s.chars().next().unwrap() == 'x' {
                    u32::from_str_radix(&s[1..], 16).unwrap()
                } else {
                    u32::from_str_radix(s, 8).unwrap()
                }
            } else {
                u32::from_str(s).unwrap()
            }
        }
    }
}

SingleAccessMask: crate::AccessMask = {
    "GR" => crate::AccessMask::GENERIC_READ,
    "GW" => crate::AccessMask::GENERIC_WRITE,
    "GX" => crate::AccessMask::GENERIC_EXECUTE,
    "GA" => crate::AccessMask::GENERIC_ALL,
    "MA" => crate::AccessMask::MAXIMUM_ALLOWED,
    "AS" => crate::AccessMask::ACCESS_SYSTEM_SECURITY,
    "WO" => crate::AccessMask::WRITE_OWNER,
    "WD" => crate::AccessMask::WRITE_DACL,
    "RC" => crate::AccessMask::READ_CONTROL,
    "SD" => crate::AccessMask::DELETE,
    "CR" => crate::AccessMask::CONTROL_ACCESS,

    "CA" => crate::constants::ADS_RIGHT_DS_CONTROL_ACCESS,
    "LO" => crate::constants::ADS_RIGHT_DS_LIST_OBJECT,
    "DT" => crate::constants::ADS_RIGHT_DS_DELETE_TREE,
    "WP" => crate::constants::ADS_RIGHT_DS_WRITE_PROP,
    "RP" => crate::constants::ADS_RIGHT_DS_READ_PROP,
    "SW" => crate::constants::ADS_RIGHT_DS_SELF,
    "LC" => crate::constants::ADS_RIGHT_ACTRL_DS_LIST,
    "DC" => crate::constants::ADS_RIGHT_DS_DELETE_CHILD,
    "CC" => crate::constants::ADS_RIGHT_DS_CREATE_CHILD,
    "NW" => crate::constants::SYSTEM_MANDATORY_LABEL_NO_WRITE_UP,
    "NR" => crate::constants::SYSTEM_MANDATORY_LABEL_NO_READ_UP,
    "NX" => crate::constants::SYSTEM_MANDATORY_LABEL_NO_EXECUTE_UP,
    "FA" => *crate::constants::FILE_ALL,
    "FR" => *crate::constants::FILE_READ,
    "FW" => *crate::constants::FILE_WRITE,
    "FX" => *crate::constants::FILE_EXECUTE,
    "KA" => *crate::constants::KEY_ALL,
    "KR" => *crate::constants::KEY_READ,
    "KW" => *crate::constants::KEY_WRITE,
    "KX" => *crate::constants::KEY_EXECUTE,
}
